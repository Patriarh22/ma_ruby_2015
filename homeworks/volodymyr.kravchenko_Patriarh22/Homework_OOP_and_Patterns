Частина 1. Принципи ООП.
Предметна область: "Заклад швидкого харчування"
Предметну область закладу було розбито на 2 основних сутності (класи), кожен з яких має
функціонально подібні задачі (методи). Найбільш зручним способом було реалізація прикладу роботи
закладу у вигляді частин коду на мові Ruby.
Інтерфейс класу kitchen представлений трьома методами: make_hot_dog, make_burrito, make_donut. 
Всі інші, згідно принципу інкапсуляції, приховано в розділі private. Інші об'єкти коду не зможуть 
мати доступ до приватних методів класу, що дозволить захистити виробничий процес від некоректного
використання цих методів, або зміни порядку їх виконання.

-------------------------------------------------------------------------------------------------
class kitchen

public

def make_hot_dog
	take_roll
	put_sausage
	put_salad
	pour_ketchup
end

def make_burrito
	take_pita
	put_staffing
	put_souse
	bake(10)
end

def make_donut
	take_dought
	put_jam
	bake(15)
	sprinkle_sugar
end
end


private

def take_roll
	puts "Беремо булку видовженої форми"
end

def put_sausage
	puts "Дістаємо зварену охотничу сосиску та кладемо у булку"
end

def put_salad
	puts "Кладемо в булку салат із капусти та моркви"
end

def pour_ketchup
	puts "Поливаємо кетчупом"
end

def take_pita
	puts "Розкладаємо лаваш"
end

def put_staffing
	puts "Накладаємо начинку із тушених овочів та мяса"
end

def pour_ketchup
	puts "Поливаємо приготованим соусом"
end

def bake(minutes)
	puts "Запікаємо #{minutes} хвилин"
end

def take_dought
	puts "Беремо зготовку тіста"
end

def put_jam
	puts "Наповнюємо вишневим варенням"
end

def sprinkle_sugar
	puts "Притрушуємо цукровою пудрою"
end

end

end
-------------------------------------------------------------------------------------------------

Інтерфейс класу bar представлений трьома методами: pour_cola, make_coffee, make_hlyntveyn. 
Всі інші так само приховано розділі private.

-------------------------------------------------------------------------------------------------
class bar

public
def pour_cola
	take_bottle
	pour_drink
end

def make_coffee
	put_beans
	pour_water
	put_cup
	press_button
end

def make_hlyntveyn
	take_hlyntveyn
	heat_up
end
end

private

def take_bottle
	puts "Беремо пляшку Коли 0,5л"
end

def pour_drink
	puts "Наливаємо вміст пляшки у стакан"
end

def put_beans
	puts "Засипаємо кавові зерна у кавовий апарат"
end

def pour_water
	puts "Заливаємо воду у кавовий апарат"
end

def put_cup
	puts "Поміщаємо чашку у кавовий апарат"
end

def press_button
	puts "Натискаємо кнопку приготування кави на кавовому апараті"
end

def take_hlyntveyn
	puts "Набираємо 100мл заздалегіть приготованого глінтвейну"
end

def heat_up
	puts "Підігріваємо до температури 70 градусів"
end

end

end
-----------------------------------------------------------------------------------------------

Згідно принципу наслідування створюємо екземпляри вище наведених класів, які будуть відображати
об'єкти реального світу.

-----------------------------------------------------------------------------------------------
food = kitchen.new
drink = bar.new
-----------------------------------------------------------------------------------------------

Здійснене замовлення поміщається у змінну order і case'ом відправляється на виконання.

-----------------------------------------------------------------------------------------------
case order
	when "hot dog"
	food.make_hot_dog
	when "burritto"
	food.make_burritto
	when "donut"
	food.make_donut
	when "cola"
	drink.make_cola
	when "coffe"
	drink.make_coffee
	when "hlyntveyn"
	drink.make_hlyntveyn
	else puts "Error"
end
------------------------------------------------------------------------------------------------

Принцип поліморфізму можна представити у вигляді приладу: на кухні з'явилась необхідність змінити
технологію приготування хот догу, а саме потрібно замість однієї сосиски класти дві і зверху 
поливати гірчицею. Використовуючи наслідування, створюємо клас new_kitchen, який наслідує методи
класу kitchen. В розділ Private нового класу поміщаємо одноіменний із методом класу kitchen метод
put_sausage, який буде виконувати вже іншу дію ніж його попередник. Також додаємо метод 
pour_mustard. Створюючи відображення об'єкту реального світу необхідно в тілі коду 
використовувати вираз food = new_kitchen.new
Звісно, подібні зміни простіше вносити безпосередньо в клас kitchen, але приклад було виконано 
для демонстрації можливостей принципу поліморфізму.
------------------------------------------------------------------------------------------------
class new_kitchen < kitchen

public

def make_hot_dog
	take_roll
	put_sausage
	put_salad
	pour_ketchup
	pour_mustard
end
end

private

def put_sausage
	puts "Дістаємо дві зварені охотничі сосиски та кладемо у булку"
end

def pour_mustard
	puts "Полити гірчицею"
end

end
end
------------------------------------------------------------------------------------------------

Частина 2. Паттерни проектування.
Для демонстрації паттернів проектування в дії проаналізуємо предметну область автоматизація 
інтернет замовлень закладу швидкого харчування.
Для замовлення їжі та напоїв існує форма замовлення, де замовник вказує свої контактні дані, а 
також саме замовлення із переліку доступних. Також є таблиця БД "Menu", де є поля: "menu_id",
"name_dish", "price", "flag". Останнє поле має значення "bar/kitchen", це потрібно для 
визначення маршрутизації замовлення.
Для управління системою створено керуючий об'єкт Manager. Після відправлення замовлення із форми,
об'єкт Manager генерує об'єкт-екземпляр класу "Order", де у поля поміщаються контактні дані
особи-замовника (метод "put_info"). Також викликається метод create_hash, який формує замовлення 
у вигляді хешу, де key це ідентифікатор позиції меню ("menu_id"), а value - кількість таких
позицій ("number").

Клас "Order"
Атрибути:
- ID_замовлення
- прізвище, ім'я
- фізична адреса
- e-mail
- номер телефону
Методи:
- put_info
- create_hash
- get_hash
- get_info

Керуючий об'єкт Manager генерує об'єкт класу "Handler" та викликає його метод split_hash, який
бере (метод get_hash із об'єкту "Order") створене замовлення у вигляді хешу та формує один хеш
для кухні, а інший для бару. Для цього порівнюється key хешу із значеннями поля "menu_id" із 
БД "Menu" та приймається рішення куди перенаправити цю позицію замовлення згідно поля "flag" 
тієї ж БД.

Клас "Handler"
Атрибути
- ID_замовлення
- kitchen_hash
- bar_hash
Методи:
- split_hash
- count_cost

Manager генерує 2 об'єкти класу "Execution". Один із методом get_kitchen_hash (дістає із об'єкту
"Hendler" хеш kitchen_hash та методом send_to_kitchen відправляє замовлення на комп'ютер що 
знаходиться на кухні), другий екземпляр із методами get_bar_hash та send_to_bar відповідно. Поле
"Стан виконання" в об'єктах типу "Execution" за замовчуванням має значення "false". Як тільки
замовлення фізично виконано в одному з підрозділів, стан відмічається як true та викликається
метод "back_to_manager" (повідомляє Manager, що замовлення в одному з підрозділів виконано).
Manager оцінює стан виконання конкретного замовлення вцілому (скажімо власним методом 
check_order) та в разі позитивного результату викликає метод "count_cost" об'єкту "Handler".
Метод "count_cost" рахує загальну вартість замовлення на основі хешу замовлення та поля "price"
БД "Menu". Далі викликається метод "send_order", який дістає контактні дані замовника (метод 
"get_info" об'єкту "Order") і результати виконання методу "count_cost" та відправляє на друк.
Після чого кур'єр отримує завдання доставити замовлення.

Клас "Execution"
Атрибути:
- ID_замовлення
- Стан виконання
Методи:
- get_kitchen_hash
- get_bar_hash
- send_to_kitchen
- send_to_bar
- back_to_manager

Для подібної системи можна було б створити дві таблиці БД, в одній з яких зберігались би дані
замовника, а в іншій історія замовлень, з використанням зв'язку один-до-багатьох. Це було б
корисно для збирання різних видів статистики, але в даному випадку такої необхідності немає.

Під час аналізу предметної області було використано паттерни проектування:
- Creator "Фабрика", який генерував однотипні об'єкти по шаблону класів
- Indirection (Посередник), який був втілений у вигляді керуючого об'єкту Manager
- Pure Fabrication у вигляді класу-обробника "Handler".
